Structure: The main function at the top of the program is where the shell code is actually executed. Generally, I used a large while loop to implement the repl, I factored out blocks of code that perform specific functions to helper methods* and then I called those helper methods within main when the functions are needed. At every iteration of the while loop, I first prompt the user and read input (by calling the helper method prompt). Then if input is read, the body of the while loop is executed. This begins by counting the arguments of the input to later construct a null-terminated arguments vector to be passed into execv (by calling the helper method count arguments). Next, I construct the arguments vector and in the process store any input/output redirection files that might be specified (by calling the helper method construct_argv). And afterwards, I copy the first argument which is the full path name to the program to be executed into a new character array and then process the first argument so that it's just the program's binary name (by calling the helper method set_first_arg). Finally, I either execute one of the built-in commands if the first argument matches one of those commmands or create a new process and pass in the full path name and the argument vectors into execv to run the program. Before continuing onto the next iteration of the while loop, I first wait for the executed command to finish, reset the space used in the current iteration, and prompt the user again.

*See helper method headers and inline comments for more details

Bugs: None known

Compile: Run make or make all to compile both shell and shellnoprompt. Run make shell or make shellnoprompt to compile one of the versions. Run make clean to clean up files.
